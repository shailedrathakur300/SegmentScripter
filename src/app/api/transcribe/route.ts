import { NextResponse } from "next/server"
import { z } from "zod"

// Define the schema for the request body
const transcribeRequestSchema = z.object({
  url: z.string().url({ message: "Invalid YouTube URL" }),
  ranges: z
    .array(
      z.object({
        start: z
          .string()
          .regex(/^[0-9]{2}:[0-5][0-9]:[0-5][0-9]$/, { message: "Invalid start time format. Use HH:MM:SS" }),
        end: z.string().regex(/^[0-9]{2}:[0-5][0-9]:[0-5][0-9]$/, { message: "Invalid end time format. Use HH:MM:SS" }),
      }),
    )
    .min(1, { message: "At least one time range is required" }),
})

export async function POST(request: Request) {
  try {
    const body = await request.json()
    const validation = transcribeRequestSchema.safeParse(body)

    if (!validation.success) {
      return NextResponse.json({ error: validation.error.flatten().fieldErrors }, { status: 400 })
    }

    const { url, ranges } = validation.data

    // In a real application, this is where you would call your Python backend.
    // For example, using fetch:
    // const pythonBackendUrl = process.env.PYTHON_BACKEND_URL;
    // if (!pythonBackendUrl) {
    //   console.error("PYTHON_BACKEND_URL environment variable is not set.");
    //   return NextResponse.json({ error: "Server configuration error." }, { status: 500 });
    // }
    // const backendResponse = await fetch(pythonBackendUrl, {
    //   method: 'POST',
    //   headers: { 'Content-Type': 'application/json' },
    //   body: JSON.stringify({ youtube_url: url, time_ranges: ranges }),
    // });
    // if (!backendResponse.ok) {
    //   const errorData = await backendResponse.json();
    //   throw new Error(errorData.detail || 'Python backend failed');
    // }
    // const data = await backendResponse.json();
    // return NextResponse.json(data);

    // --- MOCK IMPLEMENTATION ---
    // Simulate API delay
    await new Promise((resolve) => setTimeout(resolve, 1500))

    // Simulate a successful response
    const mockTranscripts = ranges.map((range) => ({
      range: `${range.start} - ${range.end}`,
      text: `This is a mock transcript for the segment from ${range.start} to ${range.end} of video ${url}. In a real application, this text would be generated by your Whisper-powered Python backend. It would accurately reflect the audio content of the specified time range. This placeholder demonstrates the expected structure and flow. The quick brown fox jumps over the lazy dog. Several fabulous dixieland jazz musicians played with zest.`,
    }))

    // Simulate a potential error (uncomment to test error handling)
    // if (Math.random() < 0.3) {
    //   return NextResponse.json({ error: "Simulated backend error: Could not process video." }, { status: 500 });
    // }

    return NextResponse.json({ transcripts: mockTranscripts })
    // --- END MOCK IMPLEMENTATION ---
  } catch (error) {
    console.error("Transcription API error:", error)
    let errorMessage = "An unexpected error occurred."
    if (error instanceof Error) {
      errorMessage = error.message
    }
    return NextResponse.json({ error: errorMessage }, { status: 500 })
  }
}
